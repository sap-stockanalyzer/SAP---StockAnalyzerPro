# dt_backend/risk/news_event_risk_dt.py â€” Phase 8
"""News/event risk layer for intraday trading.

This is *not* a prediction model. It's a seatbelt.

Inputs
------
Per-symbol: features_dt may include intraday news intel fields populated by
dt_backend/ml/ml_data_builder_intraday.py:

  news_shock_score, news_recent_articles, news_buzz_score

Global: optional backend macro_state.json (risk-off proxy) and an optional
events_calendar.json for earnings/macro times.

Outputs
-------
    {
      "risk_level": "LOW"|"MEDIUM"|"HIGH",
      "stand_down": bool,
      "penalty": 0.0..1.0,   # multiply confidence/size by this
      "reasons": [..],
    }
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, Optional

from dt_backend.core import DT_PATHS


def _safe_float(x: Any, default: float = 0.0) -> float:
    try:
        return float(x)
    except Exception:
        return float(default)


def _macro_state_path() -> Optional[Path]:
    # Prefer canonical repo config path if present.
    try:
        from config import PATHS  # type: ignore

        p = PATHS.get("macro_state") if isinstance(PATHS, dict) else None
        if p is not None:
            pp = Path(p)
            return pp
    except Exception:
        pass

    # Fallback: look in dt ml root.
    root = DT_PATHS.get("ml_data_dt") or DT_PATHS.get("dtml_data")
    if root:
        return Path(root) / "macro_state.json"
    return None


def _load_macro() -> Dict[str, Any]:
    p = _macro_state_path()
    if not p or not p.exists():
        return {}
    try:
        raw = json.loads(p.read_text(encoding="utf-8"))
        return raw if isinstance(raw, dict) else {}
    except Exception:
        return {}


def _events_path() -> Optional[Path]:
    # Optional file: symbol-> next_earnings_utc (ISO) and macro_events list
    # Can be generated by user or swing backend later.
    root = DT_PATHS.get("ml_data_dt") or DT_PATHS.get("dtml_data")
    if root:
        p = Path(root) / "events_calendar.json"
        return p
    return None


def _load_events() -> Dict[str, Any]:
    p = _events_path()
    if not p or not p.exists():
        return {}
    try:
        raw = json.loads(p.read_text(encoding="utf-8"))
        return raw if isinstance(raw, dict) else {}
    except Exception:
        return {}


def _parse_iso(ts: str) -> Optional[datetime]:
    try:
        s = (ts or "").strip()
        if not s:
            return None
        if s.endswith("Z"):
            s = s[:-1] + "+00:00"
        dt = datetime.fromisoformat(s)
        if dt.tzinfo is None:
            dt = dt.replace(tzinfo=timezone.utc)
        return dt.astimezone(timezone.utc)
    except Exception:
        return None


def assess_symbol_risk(
    *,
    symbol: str,
    features_dt: Dict[str, Any] | None,
    now_utc: Optional[datetime] = None,
) -> Dict[str, Any]:
    """Return risk assessment for a symbol."""

    now = now_utc or datetime.now(timezone.utc)
    feats = features_dt if isinstance(features_dt, dict) else {}
    sym = str(symbol).upper().strip()

    shock = abs(_safe_float(feats.get("news_shock_score"), 0.0))
    articles = _safe_float(feats.get("news_recent_articles"), 0.0)
    buzz = abs(_safe_float(feats.get("news_buzz_score"), 0.0))

    macro = _load_macro()
    vix = _safe_float(macro.get("vix") or macro.get("vix_close"), 0.0)
    spy_pct = _safe_float(macro.get("spy_pct") or macro.get("spy_pct_decimal") or macro.get("sp500_pct_decimal"), 0.0)
    breadth = _safe_float(macro.get("breadth") or macro.get("breadth_proxy"), 0.0)

    # Crude but useful risk-off: high VIX + negative tape + weak breadth.
    risk_off = bool(vix >= 22.0 and spy_pct <= -0.008 and breadth <= 0.0)

    events = _load_events()
    earnings_ts = None
    try:
        earnings_ts = _parse_iso(str((events.get("earnings") or {}).get(sym) or ""))
    except Exception:
        earnings_ts = None

    reasons = []
    penalty = 1.0
    level = "LOW"
    stand_down = False

    # Symbol news shock gating
    if shock >= 0.85 or articles >= 25:
        level = "HIGH"
        penalty *= 0.40
        reasons.append("news_shock_high")
    elif shock >= 0.55 or articles >= 10 or buzz >= 0.60:
        level = "MEDIUM"
        penalty *= 0.70
        reasons.append("news_shock_medium")

    # Earnings proximity (default: stand down within 60 minutes)
    if earnings_ts is not None:
        mins = (earnings_ts - now).total_seconds() / 60.0
        if -60 <= mins <= 60:
            stand_down = True
            level = "HIGH"
            penalty = 0.0
            reasons.append("earnings_window")
        elif 0 < mins <= 6 * 60:
            level = max(level, "MEDIUM")
            penalty *= 0.60
            reasons.append("earnings_soon")

    # Global risk-off penalty
    if risk_off:
        level = "HIGH" if level != "HIGH" else "HIGH"
        penalty *= 0.60
        reasons.append("macro_risk_off")

    penalty = max(0.0, min(1.0, float(penalty)))
    if stand_down:
        penalty = 0.0

    return {
        "risk_level": level,
        "stand_down": bool(stand_down),
        "penalty": float(penalty),
        "reasons": reasons,
        "debug": {
            "shock": shock,
            "articles": articles,
            "buzz": buzz,
            "vix": vix,
            "spy_pct": spy_pct,
            "breadth": breadth,
            "risk_off": risk_off,
            "earnings_ts": (earnings_ts.isoformat() if earnings_ts else None),
        },
    }


def risk_adjust_policy(
    *,
    action: str,
    confidence: float,
    p_hit: float,
    risk: Dict[str, Any] | None,
) -> Dict[str, Any]:
    """Apply news/event risk to a policy decision.

    Returns a dict with possibly adjusted action/confidence/p_hit and a note.
    """

    a = str(action or "").upper()
    conf = _safe_float(confidence, 0.0)
    ph = _safe_float(p_hit, conf)
    r = risk if isinstance(risk, dict) else {}

    if bool(r.get("stand_down")):
        return {
            "action": "STAND_DOWN",
            "confidence": 0.0,
            "p_hit": 0.0,
            "note": "news_event_stand_down",
        }

    penalty = max(0.0, min(1.0, _safe_float(r.get("penalty"), 1.0)))
    if a in {"BUY", "SELL"} and penalty < 1.0:
        conf = conf * penalty
        ph = ph * penalty

    return {
        "action": a,
        "confidence": float(max(0.0, min(1.0, conf))),
        "p_hit": float(max(0.0, min(1.0, ph))),
        "note": "news_event_penalty" if penalty < 1.0 else "",
    }
